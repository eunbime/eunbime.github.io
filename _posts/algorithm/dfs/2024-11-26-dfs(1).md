---
title: 깊이 우선 탐색(DFS) / 타겟 넘버
date: 2024-11-26 08:50:00 +09:00
categories: [알고리즘, 풀이]
tags: [JavaScript, 알고리즘, DFS]
---

## ★ 타겟 넘버 (DFS)

이 코드는 **타겟 넘버 문제**를 해결하기 위한 **깊이 우선 탐색(DFS)** 알고리즘을 구현한 예제다.

DFS를 활용하여 모든 경우의 수를 탐색하고, 목표 값에 도달하는 경우를 세는 방식으로 문제를 해결한다.

```jsx
function solution(numbers, target) {
  let answer = 0; // 경우의 수 초기화
  const length = numbers.length; // 숫자 배열의 길이 저장

  function dfs(count, sum) {
    if (count === length) {
      // 모든 숫자를 탐색한 경우
      if (sum === target) {
        // 목표 숫자와 합이 일치하면
        answer++; // 경우의 수 증가
      }
      return;
    }

    // 현재 숫자에 +를 적용한 경우
    dfs(count + 1, sum + numbers[count]);
    // 현재 숫자에 -를 적용한 경우
    dfs(count + 1, sum - numbers[count]);
  }

  dfs(0, 0); // 탐색 시작

  return answer; // 가능한 경우의 수 반환
}
```

---

### DFS 함수 - `dfs(count, sum)`

재귀적으로 호출하여 `count`번째 숫자까지 선택했을 때, 누적된 합 `sum`을 계산한다.

1. **기저 조건**:
   - `count === length`(모든 숫자를 탐색한 경우):
     - 현재까지의 합 `sum`이 `target`과 같으면 `answer`를 증가.
     - 재귀 종료.
2. **재귀 호출**:
   - 현재 숫자에 `+`를 적용한 경우.
   - 현재 숫자에 ``를 적용한 경우.

---

### 전체 동작 과정

1. 초기 상태에서 `dfs(0, 0)`을 호출하여 탐색 시작.
2. 탐색을 진행하면서 각 숫자에 대해 `+`와 ``를 적용한 두 경로로 분기.
3. 모든 경로를 탐색한 후, 가능한 경우의 수 `answer`를 반환.

---

### 탐색 과정

- **트리 형태로 모든 경우의 수 탐색**:

  ```
                      0
                  +1     -1
              +1   -1  +1   -1
          +1  -1 +1 -1 +1 -1 +1 -1
        +1 ...
  ```

- 각 경로에서 누적된 합이 `target`인 경우를 확인.

---

### 시간 복잡도

- **완전 탐색**으로 모든 숫자에 대해 `+`와 ``를 적용:
  - 숫자 배열의 길이가 `n`일 때, 탐색 경로는 최대 `2^n`.
  - 시간 복잡도: **O(2^n)**.

### 공간 복잡도

- 재귀 호출로 인해 호출 스택에 최대 `n`개의 함수가 쌓임.
- 공간 복잡도: **O(n)**.
