---
title: 리액트의 참조 비교(Reference Equality)
date: 2025-01-31 10:00:00 +09:00
categories: [프론트엔드, React]
tags: [참조비교]
---

## 참조 비교란?

자바스크립트에서 참조 비교는 두 값이 메모리상 동일한 위치를 가리키는지 확인하는 것이다.

```jsx
const obj1 = { name: "kim" };
const obj2 = { name: "kim" };
const obj3 = obj1;

console.log(obj1 === obj2); // false
console.log(obj1 === obj3); // true
```

## 리액트에서의 참조 비교

리액트는 다음과 같은 상황에서 참조 비교를 수행한다.

1. **컴포넌트 리렌더링 결정**
2. **의존성 배열 검사**
3. **메모이제이션된 값 비교**

### useEffect의 경우

```tsx
function MyComponent() {
  // 잘못된 방법: 매 렌더링마다 새로운 객체 생성
  useEffect(() => {
    // 로직
  }, [{ id: 1 }]);

  // 올바른 방법: 의존성을 안정적인 값으로 유지
  const stableValue = useMemo(() => ({ id: 1 }), []);
  useEffect(() => {
    // 로직
  }, [stableValue]);
}
```

## 일반적인 실수와 해결 방법

### 1. 인라인 객체 생성

```tsx
// 잘못된 방법
function Component() {
  return <ChildComponent data={{ id: 1 }} />;
}

------------------------------------------------
왜 잘못되었나요?
- 컴포넌트가 렌더링될 때마다 새로운 객체가 생성된다.
- 매 렌더링마다 { id: 1 }은 새로운 메모리 주소를 가진다.
- React.memo로 감싸진 자식 컴포넌트라도 항상 리렌더링된다.
- 불필요한 메모리 할당이 발생한다.


// 올바른 방법
function Component() {
  const data = useMemo(() => ({ id: 1 }), []);
  return <ChildComponent data={data} />;
}

------------------------------------------------
왜 올바른가요?
- useMemo를 통해 객체의 참조가 유지된다.
- 의존성 배열이 비어있으므로 컴포넌트가 마운트될 때 한 번만 객체가 생성된다.
- 메모리 사용이 효율적이다.
- React.memo를 사용한 최적화가 제대로 동작한다.
```

### 2. 인라인 함수 정의

```tsx
// 잘못된 방법
function Component() {
  return <button onClick={() => console.log('clicked')}>클릭</button>;
}

-----------------------------------------------
왜 잘못되었나요?
- 매 렌더링마다 새로운 함수가 생성된다.
- 자식 컴포넌트의 props가 변경된 것으로 인식된다.
- 불필요한 리렌더링이 발생할 수 있다.
- 이벤트 리스너가 자주 재생성되면 가비지 컬렉션에 부담을 줄 수 있다.


// 올바른 방법
function Component() {
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);

  return <button onClick={handleClick}>클릭</button>;
}

--------------------------------------------------
왜 올바른가요?
- useCallback을 통해 함수의 참조가 유지된다.
- 컴포넌트가 리렌더링되어도 동일한 함수 참조를 사용한다.
- 메모리 사용이 효율적이다.
- 이벤트 핸들러의 안정성이 보장된다.

```

## 최적화 방법

### 1. useMemo 활용

```tsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

### 2. useCallback 활용

```tsx
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

### 3. 상태 업데이트 최적화

```tsx
// 비효율적인 방법
setState(newObject);
--------------------------------------------
왜 비효율적인가요?
- 데이터가 실제로 변경되지 않았어도 항상 상태를 업데이트한다.
- 불필요한 리렌더링이 발생할 수 있다.
- 상태 관리 라이브러리의 성능 최적화 기능을 제대로 활용하지 못한다.

// 효율적인 방법
setState(prev => {
  if (prev === newObject) return prev;
  return newObject;
});
-----------------------------------------------
왜 효율적인가요?
- 실제 데이터 변경이 있을 때만 상태를 업데이트한다.
- 불필요한 리렌더링을 방지한다.
- 메모리와 성능 측면에서 효율적이다.
- 상태 관리의 예측 가능성이 높아진다.

```

## 실제 사용 사례

Zustand 스토어에서의 최적화 예시

```tsx
// 기존 코드
const useStore = create((set) => ({
  data: null,
  setData: (newData) => set({ data: newData })
}));

// 최적화된 코드
const useStore = create((set) => ({
  data: null,
  setData: (newData) =>
    set((state) => {
      if (state.data === newData) return state;
      return { data: newData };
    })
}));
```

## **주의사항**

- **과도한 최적화 주의**

```tsx
// 🤔 항상 필요한 것은 아님*

function SimpleComponent({ onSimpleClick }) {
  // 단순한 클릭 이벤트의 경우 useCallback이 불필요할 수 있다.*

  return <button onClick={onSimpleClick}>클릭</button>;
}
```

- **의존성 배열 관리**

```tsx
// 주의: 의존성이 필요한 경우*

const memoizedValue = useMemo(() => {
  return calculateValue(prop1, prop2);
}, [prop1, prop2]); // 관련 의존성을 반드시 포함
```

이러한 최적화는 애플리케이션의 규모와 복잡도에 따라 선택적으로 적용해야 한다. **항상 성능 측정을 통해 실제로 최적화가 필요한지 판단하는 것이 중요하다.**

## 결론

참조 비교를 이해하고 적절히 활용하는 것은 리액트 애플리케이션의 성능 최적화에 매우 중요하다. 하지만 모든 것을 메모이제이션하는 것은 오히려 역효과를 낼 수 있으므로, 실제 성능 문제가 있는 경우에만 적용하는 것이 좋다.
