---
title: React에서 디바운싱과 스로틀링 구현하기
date: 2025-01-31 10:00:00 +09:00
categories: [프론트엔드, React]
tags: [React]
---

# React에서 디바운싱과 스로틀링 구현하기

쓰로틀링과 디바운싱은 웹 애플리케이션의 성능 최적화를 위한 필수적인 기술이다. 각각의 개념과 실제 구현 방법을 자세히 알아보자.

## 쓰로틀링 (Throttling)

### 1. 기본 구현

```jsx
function throttle(func, limit) {
  let inThrottle;

  return function (...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

// 사용 예시
const throttledScroll = throttle(() => {
  console.log("스크롤 이벤트 처리");
}, 1000);

window.addEventListener("scroll", throttledScroll);
```

### 2. 실제 활용 예시 - 실시간 검색

```jsx
function SearchComponent() {
  const [query, setQuery] = useState("");

  // API 호출 쓰로틀링
  const throttledSearch = useCallback(
    throttle(async (searchTerm) => {
      try {
        const results = await fetch(`/api/search?q=${searchTerm}`);
        const data = await results.json();
        setSearchResults(data);
      } catch (error) {
        console.error("검색 실패:", error);
      }
    }, 1000),
    []
  );

  return (
    <input
      type="text"
      value={query}
      onChange={(e) => {
        setQuery(e.target.value);
        throttledSearch(e.target.value);
      }}
    />
  );
}
```

## 디바운싱 (Debouncing)

### 1. 기본 구현

```jsx
function debounce(func, delay) {
  let timeoutId;

  return function (...args) {
    clearTimeout(timeoutId);

    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// 사용 예시
const debouncedResize = debounce(() => {
  console.log("리사이즈 이벤트 처리");
}, 300);

window.addEventListener("resize", debouncedResize);
```

### 2. 실제 활용 예시 - 자동완성 검색

```jsx
function AutocompleteSearch() {
  const [suggestions, setSuggestions] = useState([]);

  const debouncedFetch = useCallback(
    debounce(async (searchTerm) => {
      if (searchTerm.length < 2) return;

      try {
        const response = await fetch(`/api/suggestions?q=${searchTerm}`);
        const data = await response.json();
        setSuggestions(data);
      } catch (error) {
        console.error("자동완성 검색 실패:", error);
      }
    }, 300),
    []
  );

  return (
    <div>
      <input
        type="text"
        onChange={(e) => debouncedFetch(e.target.value)}
        placeholder="검색어를 입력하세요"
      />
      <ul>
        {suggestions.map((item) => (
          <li key={item.id}>{item.text}</li>
        ))}
      </ul>
    </div>
  );
}
```

## 커스텀 훅으로 구현

### 1. useThrottle

```jsx
function useThrottle(callback, delay) {
  const [isThrottled, setIsThrottled] = useState(false);

  const throttledCallback = useCallback(
    (...args) => {
      if (!isThrottled) {
        callback(...args);
        setIsThrottled(true);

        setTimeout(() => {
          setIsThrottled(false);
        }, delay);
      }
    },
    [callback, delay, isThrottled]
  );

  return throttledCallback;
}

// 사용 예시
function ScrollTracker() {
  const handleScroll = useThrottle(() => {
    console.log("스크롤 위치:", window.scrollY);
  }, 1000);

  useEffect(() => {
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, [handleScroll]);

  return <div>스크롤 추적 중...</div>;
}
```

### 2. useDebounce

```jsx
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}

// 사용 예시
function SearchInput() {
  const [searchTerm, setSearchTerm] = useState("");
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearchTerm) {
      performSearch(debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);

  return (
    <input
      type="text"
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
    />
  );
}
```

## 실제 사용 사례

### 1. 무한 스크롤 (Throttling)

```jsx
function InfiniteScroll() {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(1);

  const throttledHandleScroll = useThrottle(() => {
    const { scrollTop, clientHeight, scrollHeight } = document.documentElement;

    if (scrollTop + clientHeight >= scrollHeight - 20) {
      setPage((prev) => prev + 1);
    }
  }, 500);

  useEffect(() => {
    window.addEventListener("scroll", throttledHandleScroll);
    return () => window.removeEventListener("scroll", throttledHandleScroll);
  }, [throttledHandleScroll]);

  return (
    <div>
      {items.map((item) => (
        <div key={item.id}>{item.content}</div>
      ))}
    </div>
  );
}
```

### 2. 실시간 입력 폼 (Debouncing)

```jsx
function LiveValidationForm() {
  const [email, setEmail] = useState("");
  const debouncedEmail = useDebounce(email, 300);

  useEffect(() => {
    async function validateEmail() {
      try {
        const response = await fetch(
          `/api/validate-email?email=${debouncedEmail}`
        );
        const { isValid } = await response.json();
        setIsEmailValid(isValid);
      } catch (error) {
        console.error("이메일 검증 실패:", error);
      }
    }

    if (debouncedEmail) {
      validateEmail();
    }
  }, [debouncedEmail]);

  return (
    <input
      type="email"
      value={email}
      onChange={(e) => setEmail(e.target.value)}
      placeholder="이메일을 입력하세요"
    />
  );
}
```

## 결론

쓰로틀링과 디바운싱은 각각의 사용 사례에 맞게 적절히 선택하여 사용해야 한다. 쓰로틀링은 일정 주기로 실행을 보장해야 할 때, 디바운싱은 연속된 이벤트의 마지막 실행만 필요할 때 사용하면 효과적이다.
