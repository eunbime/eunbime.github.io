---
title: 자바스크립트의 함수 선언 방식
date: 2024-01-31 10:00:00 +09:00
categories: [프론트엔드, JavaScript]
tags: [JavaScript]
---

### 자바스크립트 함수 선언 방식

자바스크립트에서 함수를 선언하는 방식은 크게 **함수 선언문**, **함수 표현식**, **화살표 함수**로 나뉜다. 각 방식은 동작 방식과 스코프, `this` 바인딩에서 차이를 보이며, 올바른 함수 사용을 위해 이해해야 할 중요한 개념이다.

---

## 1. 함수 선언문 (Function Declaration)

```
function greet() {
  console.log("Hello, world!");
}
greet(); // "Hello, world!"

```

### 특징

- `function` 키워드를 사용하여 선언한다.
- **함수 호이스팅 발생**: 선언된 함수가 코드의 어느 위치에서든 호출 가능하다.
- 가독성이 높아 코드의 구조를 명확히 표현할 수 있다.

### 함수 선언문의 호이스팅

함수 선언문은 **전체 함수가 메모리에 저장된 후 코드가 실행**되므로, 선언 전에 호출해도 정상 동작한다.

```
sayHello(); // "Hello!"
function sayHello() {
  console.log("Hello!");
}

```

---

## 2. 함수 표현식 (Function Expression)

```
const greet = function () {
  console.log("Hello, world!");
};
greet(); // "Hello, world!"

```

### 특징

- 변수를 선언하고, 그 변수에 익명 함수를 할당하는 방식이다.
- **변수 호이스팅 발생 (undefined로 초기화)**
  - 선언 이전에 호출할 경우 `TypeError` 발생

### 함수 표현식을 사용하는 이유

1. **호이스팅 문제 해결**
   - 함수 선언문은 코드 구조와 무관하게 어디서든 호출 가능하지만, 이는 코드 가독성을 저하시킬 수 있다.
   - 함수 표현식은 선언 이후에만 사용할 수 있어 가독성과 유지보수성이 향상된다.
2. **콜백 함수로 활용 가능**
   - 함수를 변수에 저장하면 고차 함수에 전달하는 콜백 함수로 사용하기 용이하다.

### 함수 표현식의 호이스팅

- 함수 표현식은 변수 선언 부분만 호이스팅되며, 함수 값은 런타임에 할당된다.
- 즉, **함수 호이스팅이 아닌 변수 호이스팅이 발생**한다.

```
console.log(greet); // undefined
greet(); // ❌ TypeError: greet is not a function

var greet = function () {
  console.log("Hello!");
};

```

- 변수 `greet`는 `undefined`로 초기화되므로 함수 호출 시 `undefined()`가 되어 오류 발생
- 따라서, 함수 표현식은 반드시 선언 이후에만 호출해야 한다.

---

## 3. 화살표 함수 (Arrow Function)

```
const greet = () => console.log("Hello, world!");
greet(); // "Hello, world!"

```

### 특징

- ES6에서 도입된 함수 선언 방식
- 문법이 간결하여 가독성이 좋음
- **`this` 바인딩이 없음** (기존 함수와 가장 큰 차이점)

### 화살표 함수와 `this`

기존 함수는 호출 방식에 따라 `this`가 동적으로 결정된다.

```
function normalFunction() {
  console.log(this);
}
normalFunction(); // window (브라우저 환경)

```

하지만 화살표 함수는 **자신만의 `this`를 가지지 않고, 상위 스코프의 `this`를 그대로 사용**한다.

```
const obj = {
  value: 10,
  method: function () {
    const arrowFunc = () => {
      console.log(this.value); // this는 obj를 가리킴
    };
    arrowFunc();
  },
};

obj.method(); // 10

```

### 화살표 함수가 필요한 이유

- 콜백 함수 내부에서 `this`를 유지해야 하는 경우 유용하다.

```
const button = document.querySelector("button");

// 일반 함수 사용 시 this 문제 발생
button.addEventListener("click", function () {
  console.log(this); // button 요소
});

// 화살표 함수 사용 시 해결
button.addEventListener("click", () => {
  console.log(this); // 화살표 함수의 this는 상위 스코프인 window를 가리킴
});

```

---

## 4. 함수 선언 방식 비교

| 방식            | 선언 방식         | 호이스팅                              | `this` 바인딩           | 사용 추천                                |
| --------------- | ----------------- | ------------------------------------- | ----------------------- | ---------------------------------------- |
| **함수 선언문** | `function` 키워드 | ✅ 전체 함수가 호이스팅               | 동적 결정               | 일반적인 함수 정의                       |
| **함수 표현식** | 변수에 함수 할당  | ❌ 변수만 호이스팅 (값은 런타임 할당) | 동적 결정               | 콜백 함수, 명확한 호출 순서              |
| **화살표 함수** | `=>` 사용         | ❌ 없음                               | 상위 스코프 `this` 유지 | `this`를 유지해야 하는 경우, 간결한 함수 |

---

## 5. 결론: 언제 어떤 함수를 사용할까?

- **함수 선언문**: 일반적인 함수 정의에 적합
- **함수 표현식**: 선언 이전에 호출할 일이 없는 경우, 콜백 함수로 사용
- **화살표 함수**: `this` 바인딩이 필요 없는 경우, 특히 `setTimeout`, `eventListener`, `map/filter/reduce` 등의 콜백 함수에 유용
