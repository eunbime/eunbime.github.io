---
title: 자바스크립트의 클로저(Closure)
date: 2025-01-25 10:00:00 +09:00
categories: [프론트엔드, JavaScript]
tags: [JavaScript]
---

# 클로저(Closure)란?

- 클로저(Closure)는 **함수와 그 함수가 선언된 렉시컬 환경의 조합**이다.

즉, **내부 함수가 외부 함수의 변수에 접근할 수 있으며, 외부 함수의 실행이 끝난 후에도 해당 변수들을 계속 유지할 수 있는 특성을 가진다.**

---

## 1. 클로저의 개념

클로저는 **내부 함수가 선언된 시점의 환경(렉시컬 환경, Lexical Environment)을 기억**하고 있다가,

이후 내부 함수가 실행될 때 해당 환경에 접근할 수 있도록 해주는 기능이다.

```
function outer() {
  let count = 0; // 외부 함수의 변수

  return function inner() {
    count++;
    console.log(`현재 count 값: ${count}`);
  };
}

const counter = outer(); // outer() 실행 후 inner() 반환
counter(); // "현재 count 값: 1"
counter(); // "현재 count 값: 2"
counter(); // "현재 count 값: 3"

```

### 실행 과정

1. `outer()`가 실행되면서 **`count` 변수를 선언**하고, 내부 함수 `inner()`를 반환한다.
2. `counter` 변수에 `inner` 함수를 저장하고 실행하면, **`inner()`가 `count` 변수에 접근 가능**하다.
3. `outer()`의 실행이 끝나더라도, `count` 변수는 **`inner()`가 참조하고 있기 때문에 사라지지 않는다.**
4. `counter()`를 호출할 때마다 `count` 값이 증가하는 상태를 유지한다.

---

## 2. 클로저의 활용 사례

### 2-1. **private 변수(정보 은닉)**

클로저를 사용하면 **외부에서 직접 접근할 수 없는 변수를 만들 수 있다.**

```
function createCounter() {
  let count = 0; // private 변수

  return {
    increment: function () {
      count++;
      console.log(`증가: ${count}`);
    },
    decrement: function () {
      count--;
      console.log(`감소: ${count}`);
    },
    getCount: function () {
      return count;
    },
  };
}

const counter = createCounter();
counter.increment(); // "증가: 1"
counter.increment(); // "증가: 2"
counter.decrement(); // "감소: 1"

console.log(counter.count); // undefined (외부에서 직접 접근 불가능)
console.log(counter.getCount()); // 1 (getter 메서드를 통해 접근 가능)

```

### **💡 설명**

- `count` 변수는 **`createCounter()` 내부에서 선언**되었기 때문에 외부에서 직접 접근할 수 없다.
- `increment()`, `decrement()`, `getCount()` 같은 **메서드만을 통해 `count` 값을 변경하거나 가져올 수 있다.**
- 즉, **클로저를 이용해 데이터 보호(private 변수)를 구현**할 수 있다.

---

### 2-2. **한 번만 실행되는 함수(초기화 함수)**

한 번 실행된 후 다시 호출해도 값이 변경되지 않도록 **초기화 함수**를 만들 수 있다.

```
const initialize = (function () {
  let initialized = false;

  return function () {
    if (!initialized) {
      console.log("초기화 수행!");
      initialized = true;
    } else {
      console.log("이미 초기화됨!");
    }
  };
})();

initialize(); // "초기화 수행!"
initialize(); // "이미 초기화됨!"
initialize(); // "이미 초기화됨!"

```

### **💡 설명**

- \*즉시 실행 함수(IIFE)**를 사용하여 `initialized` 변수를 **한 번만 설정할 수 있도록 제한\*\*한다.
- 이후 `initialize()`를 다시 호출하면 **기존 상태(`initialized = true`)가 유지되어 재실행되지 않는다.**
- 이런 패턴은 **애플리케이션의 설정 값 초기화 등에 유용**하다.

---

### 2-3. **이벤트 리스너에서의 사용**

클로저를 사용하면 이벤트 핸들러에서 특정 값을 유지할 수 있다.

```
function createButton(label) {
  let count = 0; // 버튼 클릭 횟수 저장

  const button = document.createElement("button");
  button.innerText = `${label} (클릭: 0)`;

  button.addEventListener("click", function () {
    count++;
    button.innerText = `${label} (클릭: ${count})`;
  });

  document.body.appendChild(button);
}

createButton("버튼 1");
createButton("버튼 2");

```

### **💡 설명**

- 버튼을 클릭할 때마다 `count` 값을 증가시키고, 버튼 텍스트를 변경한다.
- **각 버튼마다 별도의 `count` 변수를 유지**할 수 있다.
- 이는 **클로저가 함수별 개별적인 환경을 저장할 수 있기 때문**이다.

---

## 3. 클로저의 메모리 관리 주의점

클로저는 유용하지만, **가비지 컬렉션(자동 메모리 해제)이 되지 않아 메모리 누수가 발생할 수 있다.**

### **❌ 잘못된 예시:**

```
function createBigClosure() {
  let largeArray = new Array(1000000).fill("📦"); // 100만 개의 요소

  return function () {
    console.log(largeArray[0]); // 내부 함수가 largeArray를 계속 참조
  };
}

const bigFunction = createBigClosure();
// bigFunction()을 사용하지 않아도 largeArray가 메모리에 남아 있음

```

### **✅ 해결 방법:**

필요 없는 클로저의 참조를 `null`로 설정하여 메모리 해제를 유도한다.

```
let bigFunction = createBigClosure();
bigFunction = null; // 클로저가 참조하는 데이터 해제

```

---

## 4. 클로저 정리

### ✅ 클로저의 특징

✔️ **내부 함수가 외부 함수의 변수를 참조할 수 있다.**

✔️ **외부 함수 실행이 끝나도 내부 함수는 환경을 유지한다.**

✔️ **데이터 은닉, 상태 유지, 함수형 프로그래밍에 유용하다.**

✔️ **메모리 관리에 주의해야 한다.**

### ✅ 클로저의 활용

💡 **private 변수 생성** (데이터 보호 및 정보 은닉)

💡 **초기화 함수** (한 번만 실행되는 함수)

💡 **이벤트 핸들러** (버튼 클릭 횟수 저장 등)

💡 **캐싱 기능** (비효율적인 연산 결과 저장)

**클로저를 활용하면 보다 효율적이고 유지보수하기 쉬운 자바스크립트 코드를 작성할 수 있다!** 🚀
