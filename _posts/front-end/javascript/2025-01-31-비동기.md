---
title: 자바스크립트에서 비동기의 의미와 동작 방식
date: 2025-01-31 10:00:00 +09:00
categories: [프론트엔드, JavaScript]
tags: [JavaScript]
---

# 자바스크립트에서 비동기의 의미와 동작 방식

자바스크립트는 **싱글 스레드(Single Thread) 기반의 언어**이지만, 비동기 처리를 통해 효율적인 작업 수행이 가능하다. 이번 글에서는 비동기 처리의 개념과 동작 방식, 그리고 자바스크립트에서 이를 다루는 방법을 정리한다.

---

## 1. 비동기의 의미

### 1-1. 싱글 스레드와 비동기

자바스크립트는 **싱글 스레드** 기반의 언어로, 한 번에 하나의 작업만 처리할 수 있다.

하지만 네트워크 요청, 파일 읽기, 타이머 등의 작업을 실행하는 동안 **다른 코드가 실행될 수 있도록** 비동기 처리가 필요하다.

즉, **비동기 처리란 코드 실행이 완료될 때까지 기다리지 않고, 다음 코드가 실행될 수 있도록 하는 방식**을 의미한다.

### 1-2. 비동기 처리의 필요성

비동기 처리는 다음과 같은 경우에 필수적이다.

- **네트워크 요청 (AJAX, Fetch API)**
- **파일 시스템 작업 (Node.js 파일 읽기/쓰기)**
- **타이머 (setTimeout, setInterval)**
- **이벤트 리스너 (addEventListener)**

동기적으로 실행하면 **네트워크 요청이 끝날 때까지 프로그램이 멈추게 되어 사용자 경험이 저하**된다.

비동기 처리를 활용하면 **코드가 멈추지 않고 다음 작업을 수행할 수 있어 성능과 사용자 경험이 향상**된다.

---

## 2. 비동기 코드의 동작 방식

자바스크립트 엔진은 코드 실행을 관리하기 위해 **콜 스택(Call Stack), 웹 API(Web API), 태스크 큐(Task Queue), 이벤트 루프(Event Loop)** 등의 메커니즘을 사용한다.

### 2-1. 콜 스택 (Call Stack)

콜 스택은 **현재 실행 중인 함수들을 저장하는 스택 자료구조**이다.

```
function first() {
  console.log("First");
}

function second() {
  console.log("Second");
}

first();
second();

```

1. `first()` 실행 → 콜 스택에 `first()` 추가
2. `console.log("First")` 실행 → 콜 스택에서 제거
3. `second()` 실행 → 콜 스택에 `second()` 추가
4. `console.log("Second")` 실행 → 콜 스택에서 제거

**출력 결과:**

```
First
Second

```

위처럼 모든 함수가 순차적으로 실행되는 방식이 **동기 처리**이다.

---

### 2-2. 비동기 코드 실행 흐름

자바스크립트에서 비동기 처리는 **Web API, 콜백 큐, 이벤트 루프**를 통해 이루어진다.

```
console.log("Start");

setTimeout(() => {
  console.log("Timeout");
}, 1000);

console.log("End");

```

**실행 과정:**

1. `console.log("Start")` 실행 → 콜 스택에서 제거
2. `setTimeout()` 실행 → **Web API에서 타이머 시작 후 콜 스택에서 제거**
3. `console.log("End")` 실행 → 콜 스택에서 제거
4. **1초 후** `setTimeout()`의 콜백이 **태스크 큐에 추가됨**
5. **콜 스택이 비면 이벤트 루프가 콜백을 실행**

**출력 결과:**

```
Start
End
Timeout

```

---

## 3. 자바스크립트의 비동기 처리 방식

비동기 처리를 다루는 방법에는 **콜백 함수, 프로미스(Promise), async/await**이 있다.

### 3-1. 콜백 함수 (Callback)

콜백 함수는 **비동기 작업이 완료된 후 실행되는 함수**를 의미한다.

```
function fetchData(callback) {
  setTimeout(() => {
    callback("Data Loaded");
  }, 1000);
}

fetchData((data) => {
  console.log(data); // "Data Loaded" (1초 후 출력)
});

```

하지만 **콜백 지옥(Callback Hell)** 문제가 발생할 수 있다.

```
setTimeout(() => {
  console.log("1초 후 실행");
  setTimeout(() => {
    console.log("2초 후 실행");
    setTimeout(() => {
      console.log("3초 후 실행");
    }, 1000);
  }, 1000);
}, 1000);

```

---

### 3-2. 프로미스 (Promise)

콜백 지옥을 해결하기 위해 **ES6에서 Promise가 도입되었다.**

```
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("Data Loaded");
    }, 1000);
  });
};

fetchData().then((data) => {
  console.log(data); // "Data Loaded"
});

```

### `then()`과 `catch()`

```
fetchData()
  .then((data) => console.log(data))
  .catch((error) => console.log(error));

```

### `Promise.all()`

여러 개의 프로미스를 동시에 실행할 수도 있다.

```
const p1 = new Promise((res) => setTimeout(() => res("첫 번째 완료"), 1000));
const p2 = new Promise((res) => setTimeout(() => res("두 번째 완료"), 2000));

Promise.all([p1, p2]).then((values) => {
  console.log(values); // ["첫 번째 완료", "두 번째 완료"]
});

```

---

### 3-3. `async`와 `await`

`async/await`는 **Promise를 더 직관적으로 사용할 수 있도록 도와주는 문법**이다.

```
const fetchData = () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("Data Loaded");
    }, 1000);
  });
};

async function getData() {
  console.log("Fetching...");
  const data = await fetchData();
  console.log(data);
}

getData();

```

**실행 결과:**

```
Fetching...
(1초 후) Data Loaded

```

### `try/catch`로 에러 처리

```
async function getData() {
  try {
    const data = await fetchData();
    console.log(data);
  } catch (error) {
    console.log("Error:", error);
  }
}

```

---

## 4. 비동기 처리 방식 비교

| 방식          | 특징                           | 단점                                 |
| ------------- | ------------------------------ | ------------------------------------ |
| 콜백 함수     | 간단한 비동기 처리 가능        | 콜백 지옥 발생 가능                  |
| 프로미스      | 체이닝(`then`)으로 가독성 향상 | `.then()`과 `.catch()`의 중첩 가능성 |
| `async/await` | 동기 코드처럼 작성 가능        | `try/catch`로 에러 처리 필요         |

---

## 5. 결론

- **자바스크립트는 싱글 스레드 기반**이지만, **비동기 처리를 통해 효율적인 작업 수행**이 가능하다.
- **비동기 작업들은 Web API에서 처리되고, 이벤트 루프를 통해 콜백 큐에서 실행된다.**
- **콜백, Promise, async/await을 활용해 비동기 코드를 관리할 수 있다.**
- **비동기 처리를 올바르게 사용하면 성능과 사용자 경험을 개선할 수 있다.**
