---
title: 깊은 복사와 얕은 복사의 차이
date: 2025-02-01 10:00:00 +09:00
categories: [프론트엔드, JavaScript]
tags: [JavaScript]
---

# 깊은 복사와 얕은 복사의 차이

객체를 복사할 때, 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)는 **중첩된 객체를 어떻게 다루느냐**에 따라 차이가 있다.

올바른 복사 방식을 선택하면, 원본 객체의 데이터가 의도치 않게 변경되는 것을 방지할 수 있다.

---

## 1. 얕은 복사(Shallow Copy)

**✔️ 얕은 복사는 객체의 최상위 프로퍼티만 복사하고, 중첩된 객체는 참조값만 복사한다.**

즉, **1차원 프로퍼티는 새로운 값으로 복사되지만, 중첩된 객체는 기존 객체를 그대로 참조**하기 때문에, 중첩된 객체를 변경하면 원본 객체도 영향을 받는다.

### **✅ 얕은 복사 방법**

- **Spread 연산자 (`...`)**
- **`Object.assign()`**

### **📌 예제: 얕은 복사**

```jsx
const obj1 = {
  name: "Alice",
  details: { age: 25, city: "Seoul" }
};

// Spread 연산자를 사용한 얕은 복사
const obj2 = { ...obj1 };

obj2.name = "Bob"; // obj2의 최상위 프로퍼티 변경 (영향 X)
obj2.details.age = 30; // 중첩 객체 변경 (원본 영향 O)

console.log(obj1.name); // "Alice" (변경되지 않음)
console.log(obj2.name); // "Bob"

console.log(obj1.details.age); // 30 (원본도 변경됨)
console.log(obj2.details.age); // 30
```

> obj2.details는 여전히 obj1.details를 참조하고 있기 때문에, obj2.details.age를 변경하면 obj1.details.age도 함께 변경된다.

---

## 2. 깊은 복사(Deep Copy)

**✔️ 깊은 복사는 객체의 모든 레벨을 새로운 메모리에 복사한다.**

즉, **중첩된 객체까지 완전히 새로운 객체로 생성되므로, 복사본을 수정해도 원본 객체에 영향을 미치지 않는다.**

### **✅ 깊은 복사 방법**

1. **JSON 방식 (`JSON.stringify()` + `JSON.parse()`)**
   - 가장 간단한 방법이지만, **함수, `undefined`, `Symbol`, `Date`, `RegExp` 객체를 복사할 수 없다.**
2. **`structuredClone()` (최신 브라우저 지원)**
   - 최신 브라우저에서 제공하는 기본 API로, JSON 방식의 단점을 보완.
3. **Lodash 라이브러리의 `cloneDeep()`**
   - **가장 강력한 깊은 복사 방법**으로, 함수 및 다양한 데이터 타입까지 복사 가능.
   - 실무에서 가장 널리 사용됨.

---

### **📌 예제 1: JSON 방식의 깊은 복사**

```jsx
const obj1 = {
  name: "Alice",
  details: { age: 25, city: "Seoul" }
};

// JSON 방식의 깊은 복사
const obj2 = JSON.parse(JSON.stringify(obj1));

obj2.details.age = 30;

console.log(obj1.details.age); // 25 (원본 변경 없음)
console.log(obj2.details.age); // 30
```

> JSON.stringify()를 사용하면 문자열로 변환 후 다시 객체로 변환하므로, 새로운 객체가 생성됨.
>
> 하지만 **함수, `undefined`, `Symbol` 등의 값이 사라지는 단점**이 있다.

---

### **📌 예제 2: `structuredClone()`을 사용한 깊은 복사**

```jsx
const obj1 = {
  name: "Alice",
  details: { age: 25, city: "Seoul" },
  getInfo() {
    return `${this.name}, ${this.details.city}`;
  }
};

// structuredClone 사용 (최신 브라우저 지원)
const obj2 = structuredClone(obj1);

obj2.details.age = 30;

console.log(obj1.details.age); // 25 (원본 변경 없음)
console.log(obj2.details.age); // 30
```

> structuredClone()은 함수(getInfo())를 복사하지 않지만, Date, RegExp 등은 복사 가능하다.
>
> 최신 브라우저에서 기본 제공하는 API이므로, 성능도 우수하다.

---

### **📌 예제 3: Lodash의 `cloneDeep()`을 사용한 깊은 복사**

```jsx
import cloneDeep from "lodash/cloneDeep";

const obj1 = {
  name: "Alice",
  details: { age: 25, city: "Seoul" },
  getInfo() {
    return `${this.name}, ${this.details.city}`;
  }
};

// Lodash cloneDeep 사용
const obj2 = cloneDeep(obj1);

obj2.details.age = 30;

console.log(obj1.details.age); // 25 (원본 변경 없음)
console.log(obj2.details.age); // 30
```

> cloneDeep()은 모든 데이터 타입을 완벽하게 복사하며, 실무에서 가장 추천되는 방법이다.

---

## 3. 얕은 복사 vs 깊은 복사 비교

| 구분           | 얕은 복사 (Shallow Copy)                 | 깊은 복사 (Deep Copy)                                         |
| -------------- | ---------------------------------------- | ------------------------------------------------------------- |
| 복사 방식      | **최상위 프로퍼티만 복사**               | **모든 중첩 객체까지 복사**                                   |
| 중첩 객체 처리 | **참조(Reference) 유지**                 | **새로운 객체 생성**                                          |
| 원본 객체 영향 | ✅ 중첩 객체 변경 시 원본 영향           | ❌ 원본에 영향 없음                                           |
| 대표적인 방법  | `...` (Spread 연산자), `Object.assign()` | `JSON.stringify()`, `structuredClone()`, `lodash.cloneDeep()` |

---

## 4. 언제 어떤 복사 방식을 사용할까?

1️⃣ **단순한 객체**(1차원 구조)

→ **얕은 복사(Spread 연산자, `Object.assign()`) 사용**

```
const obj2 = { ...obj1 };

```

2️⃣ **중첩 객체가 포함된 경우**

→ **JSON 방식 (`JSON.stringify()`) 사용**

```
const obj2 = JSON.parse(JSON.stringify(obj1));

```

3️⃣ **함수, `Date`, `RegExp` 등 포함된 경우**

→ **`structuredClone()` 사용** (최신 브라우저 지원)

```
const obj2 = structuredClone(obj1);

```

4️⃣ **완벽한 깊은 복사가 필요한 경우**

→ **Lodash의 `cloneDeep()` 사용**

```
import cloneDeep from "lodash/cloneDeep";
const obj2 = cloneDeep(obj1);

```

---

## 5. 결론

✔️ **얕은 복사는 최상위 프로퍼티만 복사하고, 중첩 객체는 기존 객체를 참조한다.**

✔️ **깊은 복사는 중첩 객체까지 새로운 메모리에 복사하여, 원본과 완전히 독립적인 객체를 생성한다.**

✔️ **얕은 복사는 Spread 연산자를, 깊은 복사는 `structuredClone()`이나 `lodash.cloneDeep()`을 사용하는 것이 일반적이다.**

📌 **상황에 따라 적절한 복사 방법을 선택하여, 원치 않는 데이터 변경을 방지하는 것이 중요하다!** 🚀
