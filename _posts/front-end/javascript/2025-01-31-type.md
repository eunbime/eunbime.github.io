---
title: 자바스크립트의 원시 타입과 객체 타입
date: 2025-01-31 10:00:00 +09:00
categories: [프론트엔드, JavaScript]
tags: [JavaScript]
---

# 원시 타입과 객체 타입

자바스크립트의 데이터 타입은 크게 **원시 타입(Primitive Type)**과 **객체 타입(Object Type)**으로 나뉜다.

각 타입은 **메모리 할당 방식과 값의 저장 방식**에서 차이를 가진다.

---

## 1. 원시 타입(Primitive Type)

**✔️ 원시 타입은 변경 불가능한(Immutable) 값**이며, **값 자체가 변수에 저장**된다.

**값을 복사해서 전달하므로, 하나의 값을 변경해도 다른 값에는 영향을 주지 않는다.**

### **✅ 원시 타입 종류**

| 원시 타입   | 설명                                         |
| ----------- | -------------------------------------------- |
| `number`    | 숫자 타입 (정수, 실수 포함)                  |
| `string`    | 문자열 타입                                  |
| `boolean`   | 논리 값 (`true` 또는 `false`)                |
| `null`      | 값이 없음을 의미하는 타입                    |
| `undefined` | 값이 할당되지 않은 상태를 의미               |
| `symbol`    | 유일한 값을 생성하는 타입 (ES6 도입)         |
| `bigint`    | 매우 큰 정수를 다룰 수 있는 타입 (ES11 도입) |

### **📌 원시 타입의 특징**

1. **불변성(Immutable)**
   - 한 번 생성된 원시 타입 값은 변경할 수 없다.
   - 새로운 값을 할당하면 기존 값이 변경되는 것이 아니라 **새로운 메모리 공간을 차지**한다.
2. **값에 의한 복사(Pass by Value)**
   - 변수를 다른 변수에 할당하면, 값이 복사되어 전달된다.
   - 두 변수는 서로 독립적인 값을 가진다.

### **✅ 예제: 원시 타입의 값 복사**

```
let a = 10;
let b = a; // 값이 복사됨
b = 20;    // b만 변경됨

console.log(a); // 10
console.log(b); // 20

```

> b = a를 수행할 때, a의 값(10)이 복사되어 b에 저장된다. 이후 b를 변경해도 a에는 영향을 미치지 않는다.

---

## 2. 객체 타입(Object Type)

**✔️ 객체 타입은 변경 가능한(Mutable) 값**이며, **변수가 값이 아닌 메모리 주소(참조값)를 저장**한다.

**객체를 다른 변수에 할당하면 참조(Reference)가 전달되므로, 하나의 객체를 변경하면 참조하는 모든 변수에 영향을 준다.**

### **✅ 객체 타입 종류**

| 객체 타입  | 설명                           |
| ---------- | ------------------------------ |
| `Object`   | 키-값 쌍을 저장하는 일반 객체  |
| `Array`    | 순서가 있는 리스트 객체        |
| `Function` | 실행 가능한 코드 블록          |
| `Date`     | 날짜와 시간 정보를 다루는 객체 |
| `RegExp`   | 정규 표현식 객체               |

### **📌 객체 타입의 특징**

1. **가변성(Mutable)**
   - 객체는 생성된 후에도 내부 값을 변경할 수 있다.
2. **참조에 의한 전달(Pass by Reference)**
   - 변수를 다른 변수에 할당하면 **값이 복사되는 것이 아니라, 같은 메모리 주소를 참조하게 된다.**
   - 따라서 한 변수를 통해 객체를 변경하면, 동일한 객체를 참조하는 다른 변수에도 영향을 준다.

### **✅ 예제: 객체 타입의 참조 전달**

```
let obj1 = { name: "Alice" };
let obj2 = obj1; // obj1의 참조값이 복사됨 (객체의 주소를 공유)

obj2.name = "Bob"; // obj2를 통해 변경

console.log(obj1.name); // "Bob"
console.log(obj2.name); // "Bob"

```

> obj2 = obj1을 수행할 때, obj1의 객체 참조값(메모리 주소)이 obj2에 저장된다.
>
> 따라서 `obj2.name`을 변경하면, 같은 객체를 참조하는 `obj1.name`도 함께 변경된다.

---

## 3. 원시 타입과 객체 타입 비교

| 비교 항목      | 원시 타입                   | 객체 타입                         |
| -------------- | --------------------------- | --------------------------------- |
| 저장 방식      | **값 자체를 저장**          | **참조(메모리 주소)를 저장**      |
| 변경 가능 여부 | **불변(Immutable)**         | **가변(Mutable)**                 |
| 메모리 할당    | **새로운 메모리 공간 할당** | **같은 객체를 참조(메모리 공유)** |
| 복사 방식      | **값 복사(Pass by Value)**  | **참조 복사(Pass by Reference)**  |
| 변수 간 영향   | **독립적**                  | **같은 객체를 공유**              |

---

## 4. 객체의 참조 문제 해결 방법

### **✔️ 객체의 복사(Shallow Copy & Deep Copy)**

**객체를 복사할 때, 원본 객체와 독립적인 값을 가지도록 만들려면 깊은 복사(Deep Copy)를 해야 한다.**

### **(1) 얕은 복사(Shallow Copy)**

```
const obj1 = { name: "Alice", age: 25 };
const obj2 = { ...obj1 }; // Spread 연산자를 사용한 얕은 복사

obj2.name = "Bob"; // obj2만 변경

console.log(obj1.name); // "Alice" (변경되지 않음)
console.log(obj2.name); // "Bob"

```

> ...obj1을 사용하면 1차원 객체는 복사되지만, 중첩 객체는 여전히 참조가 공유된다.

### **(2) 깊은 복사(Deep Copy)**

```
const obj1 = { name: "Alice", details: { age: 25 } };
const obj2 = JSON.parse(JSON.stringify(obj1)); // 깊은 복사

obj2.details.age = 30; // obj2만 변경

console.log(obj1.details.age); // 25 (원본 변경 없음)
console.log(obj2.details.age); // 30

```

> JSON 방식으로 깊은 복사를 하면, 중첩 객체까지 새로운 메모리에 복사되므로 원본 객체가 변경되지 않는다.

---

## 5. 결론

✔️ **원시 타입(Primitive Type)은 값 자체를 저장하며, 값 복사(Pass by Value) 방식으로 동작하여 독립적인 값을 가진다.**

✔️ **객체 타입(Object Type)은 참조값(메모리 주소)을 저장하며, 참조 복사(Pass by Reference) 방식으로 동작하여 같은 객체를 공유한다.**

✔️ **객체를 독립적으로 유지하려면 얕은 복사(Spread 연산자) 또는 깊은 복사(JSON 방법 등)를 사용해야 한다.**
