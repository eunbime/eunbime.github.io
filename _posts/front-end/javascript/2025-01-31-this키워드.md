---
title: 자바스크립트의 this 키워드
date: 2025-01-31 10:00:00 +09:00
categories: [프론트엔드, JavaScript]
tags: [JavaScript]
---

# JavaScript의 this 키워드

자바스크립트에서 `this` 키워드는 **함수가 호출되는 방식**에 따라 그 값이 달라지는 특징을 가진다. 따라서 `this`를 올바르게 이해하고 사용하는 것이 중요하다. 이번 글에서는 `this`의 다양한 의미와 사용법을 정리한다.

---

## 1. `this` 키워드란?

`this`는 **현재 실행 컨텍스트에서의 객체 참조를 나타내는 키워드**이다.

즉, `this`가 가리키는 값은 **함수가 어떻게 호출되었는지**에 따라 결정된다.

---

## 2. `this`가 가질 수 있는 의미

### 2-1. 일반 함수에서의 `this`

일반적인 함수 호출에서 `this`는 **전역 객체**를 가리킨다.

- 브라우저 환경: `window`
- Node.js 환경: `globalThis`

```
function showThis() {
  console.log(this);
}

showThis(); // 브라우저: window, Node.js: globalThis

```

`"use strict"` 모드에서는 `this`가 `undefined`가 된다.

```
"use strict";
function showThis() {
  console.log(this);
}

showThis(); // undefined

```

### 2-2. 메서드에서의 `this`

객체의 메서드에서 `this`는 **해당 메서드를 소유한 객체**를 가리킨다.

```
const obj = {
  name: "Eunbi",
  greet() {
    console.log(this.name);
  },
};

obj.greet(); // "Eunbi"

```

그러나 메서드를 변수에 할당하면 `this`가 달라진다.

```
const greetFn = obj.greet;
greetFn(); // undefined (브라우저: window.name)

```

### 2-3. 생성자 함수에서의 `this`

생성자 함수에서 `this`는 **새로 생성된 인스턴스(객체)를 참조**한다.

```
function Person(name) {
  this.name = name;
}

const user = new Person("Eunbi");
console.log(user.name); // "Eunbi"

```

생성자 함수가 `new` 없이 호출되면 `this`가 `window`를 가리켜 의도치 않은 동작이 발생할 수 있다.

이 문제를 방지하려면 `"use strict"`를 사용하자.

```
"use strict";
function Person(name) {
  this.name = name;
}

Person("Eunbi"); // TypeError: Cannot set properties of undefined

```

### 2-4. 화살표 함수에서의 `this`

화살표 함수는 **자신만의 `this`를 가지지 않으며, 외부 스코프의 `this`를 상속**한다.

```
const obj = {
  name: "Eunbi",
  greet: () => {
    console.log(this.name);
  },
};

obj.greet(); // undefined (this는 obj가 아니라 window)

```

객체 내부에서 화살표 함수를 사용할 때 `this`를 유지해야 한다면 일반 함수를 사용해야 한다.

```
const obj = {
  name: "Eunbi",
  greet() {
    const arrow = () => console.log(this.name);
    arrow();
  },
};

obj.greet(); // "Eunbi"

```

이 패턴은 이벤트 핸들러에서도 유용하다.

```
const button = document.querySelector("button");

button.addEventListener("click", function () {
  console.log(this); // button 요소
});

button.addEventListener("click", () => {
  console.log(this); // window
});

```

---

## 3. `this`를 명시적으로 바인딩하기

`this`는 기본적으로 호출 방식에 의해 결정되지만, **`call`, `apply`, `bind`를 사용해 명시적으로 지정할 수 있다.**

### 3-1. `call()`

`call()` 메서드는 **함수를 즉시 실행하며**, `this`를 특정 객체로 바인딩할 수 있다.

```
function introduce() {
  console.log(`My name is ${this.name}`);
}

const user = { name: "Eunbi" };

introduce.call(user); // "My name is Eunbi"

```

**추가 인자가 있는 경우**

```
function introduce(age, city) {
  console.log(`My name is ${this.name}, I'm ${age} years old from ${city}`);
}

introduce.call(user, 25, "Seoul");
// "My name is Eunbi, I'm 25 years old from Seoul"

```

### 3-2. `apply()`

`apply()`는 `call()`과 비슷하지만, **인자를 배열 형태로 전달**한다.

```
introduce.apply(user, [25, "Seoul"]);

```

### 3-3. `bind()`

`bind()`는 `this`가 바인딩된 새로운 함수를 반환하며, 나중에 실행할 수 있다.

```
const boundFunc = introduce.bind(user);
boundFunc(25, "Seoul"); // "My name is Eunbi, I'm 25 years old from Seoul"

```

---

## 4. `this` 관련 주요 정리

| 호출 방식                 | `this` 값                           |
| ------------------------- | ----------------------------------- |
| 일반 함수                 | 전역 객체 (`window` / `globalThis`) |
| 객체의 메서드             | 해당 객체                           |
| 생성자 함수               | 새로 생성된 인스턴스                |
| 화살표 함수               | 상위 스코프의 `this`                |
| `call` / `apply` / `bind` | 명시적으로 설정된 객체              |

---

## 5. 결론

- `this`는 함수의 **호출 방식**에 따라 값이 결정된다.
- 화살표 함수는 `this`를 갖지 않고, 상위 스코프의 `this`를 상속한다.
- `call`, `apply`, `bind`를 사용하여 `this`를 명시적으로 설정할 수 있다.
- `this` 동작을 정확히 이해하고 사용하면 코드의 예측 가능성을 높이고, 오류를 줄일 수 있다.
