---
title: WebSocket과 SWR의 특징과 사용법
date: 2024-12-04 10:00:00 +09:00
categories: [프론트엔드, CS]
tags: [네트워크, CS]
---

프론트엔드에서 데이터를 실시간으로 업데이트하기 위한 기술로 WebSocket과 SWR이 많이 언급된다.

두 기술은 서로 다른 목적과 특성을 가지고 있기 때문에 상황에 따라 적합하게 사용해야 한다.

그러기 위해 먼저 웹소켓과 SWR의 특성들을 살펴보자.

---

## ★ 웹소켓(WebSocket)

### **웹소켓이란?**

웹소켓은 클라이언트(브라우저)와 서버 간의 **양방향 통신**을 지원하는 프로토콜이다. 연결이 한 번 성립되면 서버와 클라이언트가 **지속적으로 데이터를 주고받을 수 있는 통신 채널**이 열린다.

### **웹소켓의 사용법**

웹소켓은 보통 다음과 같은 흐름으로 사용된다:

1. 클라이언트에서 서버로 연결 요청을 보낸다.
2. 연결이 수립되면, 클라이언트와 서버는 서로 데이터를 자유롭게 주고받는다.
3. 연결을 유지하거나 필요시 닫는다.

**[예제] 웹소켓**

```jsx
const socket = new WebSocket("wss://example.com/socket");

// 연결 성공 시 실행
socket.onopen = () => {
  console.log("웹소켓 연결 성공!");
  socket.send("Hello, Server!");
};

// 서버로부터 메시지 수신
socket.onmessage = (event) => {
  console.log("서버로부터 메시지:", event.data);
};

// 연결 종료
socket.onclose = () => {
  console.log("웹소켓 연결 종료");
};
```

### **웹소켓의 장단점**

**장점**

- **실시간 데이터 전송**: 서버가 클라이언트로 데이터를 푸시(Push)할 수 있어 빠른 응답이 가능하다.
- **지속적인 연결**: HTTP처럼 요청-응답을 반복하지 않으므로 네트워크 비용이 적다.
- **실시간 기능에 최적화**: 채팅, 주식 가격 표시, 실시간 알림 등에 적합하다.

**단점**

- **복잡한 상태 관리**: 실시간 데이터 업데이트 시 상태를 관리하기 어려울 수 있다.
- **초기 설정 비용**: 연결 관리, 에러 처리 등 구현이 복잡하다.
- **브라우저 지원 제한**: 일부 오래된 브라우저에서는 지원되지 않을 수 있다.

---

## ★ **SWR (Stale-While-Revalidate)**

### **SWR이란?**

SWR은 **React 기반의 데이터 패칭 라이브러리**로, Next.js를 포함한 React 프로젝트에서 많이 사용된다. 이 이름은 HTTP 캐싱 전략인 “Stale-While-Revalidate”에서 유래했다. SWR은 캐싱된 데이터가 "오래된(stale)" 상태에서도 즉시 표시하고, 백그라운드에서 데이터를 다시 가져와(revalidate) 최신 상태를 유지한다.

**[예제] SWR**

```jsx
import useSWR from "swr";

// 데이터 패칭 함수
const fetcher = (url) => fetch(url).then((res) => res.json());

export default function User() {
  const { data, error, isLoading } = useSWR("/api/user", fetcher);

  if (error) return <div>데이터 로드 중 오류 발생!</div>;
  if (isLoading) return <div>로딩 중...</div>;

  return (
    <div>
      <h1>사용자 정보</h1>
      <p>이름: {data.name}</p>
      <p>이메일: {data.email}</p>
    </div>
  );
}
```

### **SWR의 장단점**

**장점**

- **자동 캐싱 및 재검증**: 데이터를 자동으로 캐싱하고, 오래된 데이터는 백그라운드에서 재검증한다.
- **단순한 API**: useSWR 훅을 통해 데이터를 쉽게 가져올 수 있다.
- **서버 요청 절약**: 캐싱 덕분에 불필요한 네트워크 요청이 줄어든다.
- **최신 데이터 유지**: 사용자는 항상 가장 최신 데이터를 볼 수 있다.

**단점**

- **실시간성 부족**: 실시간으로 데이터가 업데이트되는 경우에는 적합하지 않다.
- **구성 필요**: 사용자 경험을 최적화하기 위해 fetcher 함수 등을 커스터마이징해야 한다.
- **초기 렌더링 의존성**: SSR과 함께 사용하지 않으면 SEO가 필요한 페이지에서 한계가 있다.

---

## 🤔 웹소켓과 SWR을 비교해보자

| 특징            | **웹소켓(WebSocket)**                       | **SWR(Stale-While-Revalidate)**           |
| --------------- | ------------------------------------------- | ----------------------------------------- |
| **사용 목적**   | 실시간 데이터 업데이트                      | 주기적 데이터 패칭 및 캐싱                |
| **데이터 흐름** | 서버 ↔ 클라이언트 양방향 통신               | 클라이언트 → 서버 단방향 통신             |
| **실시간성**    | 매우 우수                                   | 제한적 (백그라운드 업데이트)              |
| **구현 난이도** | 상대적으로 높음                             | 상대적으로 쉬움                           |
| **적합한 사례** | 채팅, 알림, 주식 가격, 실시간 데이터 시각화 | 블로그, 사용자 정보, 일반적인 데이터 패칭 |
| **캐싱 지원**   | 없음                                        | 자동 캐싱 및 재검증                       |
| **서버 부하**   | 연결 유지로 부하 증가 가능                  | 캐싱으로 부하 감소                        |

---

## **☝️ 웹소켓과 SWR을 함께 사용하는 방법**

실제 프로젝트에서는 웹소켓과 SWR을 **보완적으로** 사용하는 경우가 많다. 예를 들어:

- **웹소켓**은 실시간 업데이트가 필요한 기능(채팅, 알림)에서 활용한다.
- **SWR**은 초기 데이터를 가져오고 캐싱하여 서버 부하를 줄인다.

**예시 시나리오**:

1. 사용자가 채팅 페이지에 접속하면, SWR을 통해 과거 메시지를 가져온다.
2. 이후, 웹소켓을 사용하여 실시간으로 새로운 메시지를 받아온다.

**[예제] 웹소켓과 SWR**

```jsx
import useSWR from "swr";
import { useEffect } from "react";
import { useChatSocket } from "./hooks/use-chat-socket";

const fetcher = (url) => fetch(url).then((res) => res.json());

export default function Chat() {
  const { data: initialMessages } = useSWR("/api/messages", fetcher);
  const { newMessage } = useChatSocket();

  useEffect(() => {
    if (newMessage) {
      // 실시간 메시지 처리 로직
    }
  }, [newMessage]);

  return (
    <div>
      {initialMessages?.map((msg) => (
        <p key={msg.id}>{msg.content}</p>
      ))}
    </div>
  );
}
```

---

## 👩‍💻 정리

웹소켓과 SWR은 서로 다른 목적과 장점을 가진 기술이다.

그러므로,

- **실시간 데이터 업데이트**가 필요하다면 웹소켓을 활용해보자
- **정적 데이터 패칭 및 캐싱**이 중요하다면 SWR을 활용해보자

두 가지의 기술을 적절히 활용한다면 효율적인 데이터 처리가 가능하면서 사용자 경험을 크게 향상시킬 수 있을 것이다.
